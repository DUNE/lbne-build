#+TITLE: Chasing Upstream Git
#+DATE: [2015-02-04 Wed 17:00]
#+DESCRIPTION: After forking a Git project it can be desireable to incorporate further development in the original repository.  If git-subtrees are used that adds and extra wrinkle.  Then, toss git-flow into the picture.
#+SETUPFILE: ~/org-pub/topics/setup.org

LBNE has forked the art and LArSoft git repositories which live definitively in "upstream" Fermilab Redmine/git into repositories in the [[https://github.com/LBNE][LBNE GitHub organization]].  The fork was made to provide independent repositories for work on a "pure" CMake build system not entangled with Fermilab-local software infrastructure.  The eventual goal is to push this new build system back upstream but until that is done a method to incorporate new "upstream" development is needed.  This topic describes how that is done.

For every package there are three repositories of interest:

 - upstream :: the Fermilab Redmine/git repository
 - downstream :: the GitHub repository
 - local :: the working repository used to sync the two 

* Branching policy

In early development there was no consistent branching in the GitHub repository.  To efficiently track upstream this consistency must be enforced as described here. 

** Upstream policy

Upstream follows =git flow= and tags releases on =master=.  Two types of tags are used:

 - package :: looks like =vX_YY_ZZ=
 - suite :: looks like =<NAME>_SUITE_vX_YY_ZZ=

Suite tags get placed regardless if new package tags are made.  Eg, the =cpp0x= commit tagged with =v1_04_08= has 8 different suite tags.

** Downstream policy

Some rules are needed to keep development of the build system itself
and chasing upstream separate and sane.  Consistent with =git flow=
these rules apply to what may and may not be pushed to GitHub:

 - new development *must only* be done in a feature branch off of =develop=
 - *never* merge any branch directly into =master= except a release branch during a =git flow= release
 - *only* merge tagged upstream releases (from =upstream/master=) and only into a =git flow= release branch as part of a release.

* Forging Upstream-Downstream Link

The script [[../scripts/upstream.py][=upstream.py=]] provides functionality to chase upstream development according to this policy.   The script provides a series of commands:

#+BEGIN_EXAMPLE
  $ upstream.py [-C <workdir>] <command> <options> <args>
#+END_EXAMPLE

Default working directory is the current working directory.

For details see:

#+BEGIN_EXAMPLE
  $ upstream.py --help
#+END_EXAMPLE

Green field setup

#+BEGIN_EXAMPLE
  $ upstream.py -C chasing init
#+END_EXAMPLE

This brings all commits and leaves local repo empty but ready for git flow.

* Initial setup

Most of the development in GitHub is done in =remove-ups*= branches.

** art

- art :: =remove-ups-1.11.3= rooted in =v1_11_03=

This version is part of this release: 

#+BEGIN_EXAMPLE
  $ upstream.py -C chasing suite-release art  v1_11_03
  v1_04_08 cpp0x
  v1_07_02 cetlib
  v3_01_01 fhicl-cpp
  v1_11_14 messagefacility
  v1_11_03 art
#+END_EXAMPLE

For the most part the non-art art packages are untouched and all the activity is in =FNALCore=

*** FNALCore

The purification for the four non-art art packages is done in FNALCore which incorporates them via =git-subtree=.  It's really difficult to figure out how to track this!

** larsoft

- larana :: =remove-ups= rooted in =v03_03_02=
- lardata :: =remove-ups= rooted in =v03_03_02=
- larcore :: =remove=ups= rooted in =v03_03_03=

Which are part of this release:

#+BEGIN_EXAMPLE
  $ upstream.py -C chasing suite-release lar  v03_03_02
  v03_02_03 larana
  v03_02_02 lardata
  v03_02_02 larevt
  v03_03_01 larpandora
  v03_02_02 larsim
  v03_02_02 larcore
  v03_02_02 lareventdisplay
  v03_02_02 larexamples
  v03_02_03 larreco
  v03_03_02 larsoft
#+END_EXAMPLE

This is actually associated with using art =v1_10_00b=.  The next highest art suite which is used is =v1_12_04= by larsoft suite =v03_04_02=.
